<p>I really like <a href="http://jhipster.github.io/">JHipster project</a>.
The server stack is clean and ready for production</p>

<ul>
  <li>Spring Boot for easy application configuration</li>
  <li>Maven or Gradle configuration for building, testing and running the application</li>
  <li>“development” and “production” profiles (both for Maven and Gradle)</li>
  <li>Spring Security</li>
  <li>Spring MVC REST + Jackson</li>
  <li>Optional WebSocket support with Spring Websocket</li>
  <li>Spring Data JPA + Bean Validation</li>
  <li>Database updates with Liquibase</li>
  <li>MongoDB support if you’d rather use NoSQL instead of a classical relational database</li>
</ul>

<p>Ready to go into production:
* Monitoring with Metrics
* Caching with ehcache (local cache) or hazelcast (distributed cache)
* Optional HTTP session clustering with hazelcast
* Optimized static resources (gzip filter, HTTP cache headers)
* Log management with Logback, configurable at runtime
* Connection pooling with HikariCP for optimum performance
* Builds a standard WAR file or an executable JAR file</p>

<p>and the client part is also clean</p>

<p>Single Web page application:</p>

<ul>
  <li>Responsive Web Design</li>
  <li>HTML5 Boilerplate</li>
  <li>Twitter Bootstrap</li>
  <li>AngularJS</li>
  <li>Full internationalization support with Angular Translate</li>
  <li>Optional WebSocket support with Spring Websocket</li>
</ul>

<p>With the great Yeoman development workflow:</p>

<ul>
  <li>Easy installation of new JavaScript libraries with Bower</li>
  <li>Build, optimization and live reload with Grunt or Gulp.js</li>
  <li>Testing with Karma and PhantomJS</li>
</ul>

<p>For me, it mainly misses some entity code geenrator that use <a href="http://www.typescriptlang.org">TypeScript</a>.</p>

<!--more-->
<p>#Tips for JHipster.</p>

<h2 id="define-your-own-servlet">Define your own servlet</h2>

<p>If you want to add your own servlet. It is quite easy. In the <em>WebConfigurer</em> class and in the method <em>onStartup</em> you can easily add declare new servlets.</p>

<p><code>java
servletContext.addServlet("foo"/*servlet name*/, MyServlet1.class /*servlet class*/);
servletContext.getServletRegistration("foo" /*servlet name*/).addMapping("/im/toto.png" /*servlet path*/);
</code></p>

<p>Now you can add your servlet. In this example, it a servlet that plays with images to get only a part of a big image.</p>

<p>```java
package com.mycompany.myapp.web.rest;</p>

<p>import java.awt.image.BufferedImage;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.OutputStream;</p>

<p>import javax.imageio.ImageIO;
import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;</p>

<p>public class MyServlet1 extends HttpServlet  {</p>

<p>@Override
  protected void doGet(HttpServletRequest req, HttpServletResponse resp)
      throws ServletException, IOException {
      ServletContext cntx= getServletContext();
        // Get the absolute path of the image
        String filename =  cntx.getRealPath(“/assets/images/hipster.png”);
        // retrieve mimeType dynamically
        String mime = cntx.getMimeType(filename);
        if (mime == null) {
            resp.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
          return;
        }
        resp.setContentType(mime);
        File file = new File(filename);
        FileInputStream in = new FileInputStream(file);
        OutputStream out = resp.getOutputStream();
        BufferedImage bigImg = ImageIO.read(file);
        BufferedImage small = bigImg.getSubimage(0, 0,200, 200);</p>

<pre><code>    // Copy the contents of the file to the output stream
     ByteArrayOutputStream baos = new ByteArrayOutputStream();
     ImageIO.write( small, "png", baos );
     baos.flush();
     byte[] imageInByte = baos.toByteArray();
   resp.setContentLength(imageInByte.length);
     out.write(imageInByte);
     out.close();
     in.close();   } }
</code></pre>

<p>```</p>

<h2 id="get-the-user-which-is-currently-logged-in">get the User which is currently logged in.</h2>
<p><code>java
userRepository.findOneByLogin(SecurityUtils.getCurrentLogin()).get();
</code></p>

<h2 id="use-hibernate-to-create-the-schema">Use Hibernate to create the schema.</h2>
<p>Sometimes, the use of liquidbase is a bit overkill especially at the beginning of a project if you just miss some attributes of your entities. In that case, you can let hibernate manage the database schema.</p>

<p>```
generate-ddl: true
 hibernate:
     ddl-auto: update</p>

<p>```</p>

<p>It does not really follow the JHipster philosophy but it is usefull when you create a new app from scratch.</p>
